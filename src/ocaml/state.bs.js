// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Player = require("./player.bs.js");
var Components = require("./components.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function init_state(num, color) {
  var players = Curry._2(Player.init_players, num, color);
  var player1 = List.hd(players);
  return /* record */[
          /* current_player */player1,
          /* players */players,
          /* routes : [] */0,
          /* destination_deck */Components.DestinationDeck[/* init_deck */3],
          /* destination_trash */Components.DestinationDeck[/* init_trash */4],
          /* choose_destinations : [] */0,
          /* train_deck */Components.TrainDeck[/* init_deck */3],
          /* train_trash */Components.TrainDeck[/* init_trash */4],
          /* taking_routes */false,
          /* error */""
        ];
}

function current_player_turn(st) {
  return st[/* current_player */0];
}

function draw_card() {
  return Pervasives.failwith("Unimplemented");
}

function take_route(st) {
  var deck = st[/* destination_deck */3];
  var tr = st[/* destination_trash */4];
  var match = Components.DestinationDeck[/* draw_card */0](deck, tr);
  return /* record */[
          /* current_player */st[/* current_player */0],
          /* players */st[/* players */1],
          /* routes */st[/* routes */2],
          /* destination_deck */match[1],
          /* destination_trash */st[/* destination_trash */4],
          /* choose_destinations */match[0],
          /* train_deck */st[/* train_deck */6],
          /* train_trash */st[/* train_trash */7],
          /* taking_routes */true,
          /* error */st[/* error */9]
        ];
}

function decided_routes(st, tickets) {
  if (List.length(tickets) > 1) {
    var player = st[/* current_player */0];
    var new_tickets = Pervasives.$at(tickets, Player.destination_tickets(player));
    var player$prime = Player.update_destination_tickets(player, new_tickets);
    return /* record */[
            /* current_player */player$prime,
            /* players */st[/* players */1],
            /* routes */st[/* routes */2],
            /* destination_deck */st[/* destination_deck */3],
            /* destination_trash */st[/* destination_trash */4],
            /* choose_destinations : [] */0,
            /* train_deck */st[/* train_deck */6],
            /* train_trash */st[/* train_trash */7],
            /* taking_routes */false,
            /* error */""
          ];
  } else {
    return /* record */[
            /* current_player */st[/* current_player */0],
            /* players */st[/* players */1],
            /* routes */st[/* routes */2],
            /* destination_deck */st[/* destination_deck */3],
            /* destination_trash */st[/* destination_trash */4],
            /* choose_destinations */st[/* choose_destinations */5],
            /* train_deck */st[/* train_deck */6],
            /* train_trash */st[/* train_trash */7],
            /* taking_routes */st[/* taking_routes */8],
            /* error */"Must at least take 1 ticket"
          ];
  }
}

function place_on_board() {
  return Pervasives.failwith("Unimplemented");
}

function score(st, _) {
  return Curry._1(Player.score, st[/* current_player */0]);
}

function routes() {
  return Pervasives.failwith("Unimplemented");
}

function longest_route(st) {
  var first = List.hd(st[/* players */1]);
  var _plyrs = st[/* players */1];
  var _best = first;
  while(true) {
    var best = _best;
    var plyrs = _plyrs;
    if (List.length(plyrs) > 0) {
      var p = List.hd(plyrs);
      var rest = List.tl(plyrs);
      if (Curry._1(Player.score, p) > Curry._1(Player.score, best)) {
        _best = p;
        _plyrs = rest;
        continue ;
      } else {
        _plyrs = rest;
        continue ;
      }
    } else {
      return best;
    }
  };
}

exports.init_state = init_state;
exports.current_player_turn = current_player_turn;
exports.draw_card = draw_card;
exports.take_route = take_route;
exports.decided_routes = decided_routes;
exports.place_on_board = place_on_board;
exports.score = score;
exports.routes = routes;
exports.longest_route = longest_route;
/* Player Not a pure module */
