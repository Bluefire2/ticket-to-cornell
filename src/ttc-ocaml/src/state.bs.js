// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Board = require("./board.bs.js");
var Player = require("./player.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Components = require("./components.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function init_state(num) {
  var players = Player.init_players(num);
  return /* record */[
          /* player_index */0,
          /* players */players,
          /* routes */Board.routes,
          /* destination_deck */Components.DestinationDeck[/* init_deck */2](/* () */0),
          /* destination_trash */Components.DestinationDeck[/* init_trash */3],
          /* choose_destinations : [] */0,
          /* train_deck */Components.TrainDeck[/* init_deck */1](/* () */0),
          /* facing_up_trains */Components.TrainDeck[/* init_faceup */6](/* () */0),
          /* train_trash */Components.TrainDeck[/* init_trash */2],
          /* taking_routes */false,
          /* error */"",
          /* turn_ended */false,
          /* last_round */false
        ];
}

function current_player(st) {
  return List.nth(st[/* players */1], st[/* player_index */0]);
}

function players(st) {
  return st[/* players */1];
}

function routes(st) {
  return st[/* routes */2];
}

function destination_items(st) {
  return /* tuple */[
          st[/* destination_deck */3],
          st[/* destination_trash */4]
        ];
}

function train_items(st) {
  return /* tuple */[
          st[/* train_deck */6],
          st[/* facing_up_trains */7],
          st[/* train_trash */8]
        ];
}

function message(st) {
  return st[/* error */10];
}

function turn_ended(st) {
  return st[/* turn_ended */11];
}

function last_round(st) {
  return st[/* last_round */12];
}

function choose_destinations(st) {
  return st[/* choose_destinations */5];
}

function score(st, _) {
  return Player.score(current_player(st));
}

function check_last_round(st) {
  var p = current_player(st);
  return Player.trains_remaining(p) <= 2;
}

function game_ended(st) {
  var _param = st[/* players */1];
  while(true) {
    var param = _param;
    if (param) {
      if (Player.last_turn(param[0])) {
        _param = param[1];
        continue ;
      } else {
        return false;
      }
    } else {
      return true;
    }
  };
}

function turn_ended_error(st) {
  return /* record */[
          /* player_index */st[/* player_index */0],
          /* players */st[/* players */1],
          /* routes */st[/* routes */2],
          /* destination_deck */st[/* destination_deck */3],
          /* destination_trash */st[/* destination_trash */4],
          /* choose_destinations */st[/* choose_destinations */5],
          /* train_deck */st[/* train_deck */6],
          /* facing_up_trains */st[/* facing_up_trains */7],
          /* train_trash */st[/* train_trash */8],
          /* taking_routes */st[/* taking_routes */9],
          /* error */"Turn has already ended for the current player.",
          /* turn_ended */st[/* turn_ended */11],
          /* last_round */st[/* last_round */12]
        ];
}

function update_players(i, new_p, lst) {
  var _i = 0;
  var new_i = i;
  var new_p$1 = new_p;
  var _acc = /* [] */0;
  var _param = lst;
  while(true) {
    var param = _param;
    var acc = _acc;
    var i$1 = _i;
    if (param) {
      var t = param[1];
      if (i$1 === new_i) {
        return Pervasives.$at(acc, Pervasives.$at(/* :: */[
                        new_p$1,
                        /* [] */0
                      ], t));
      } else {
        _param = t;
        _acc = Pervasives.$at(acc, /* :: */[
              param[0],
              /* [] */0
            ]);
        _i = i$1 + 1 | 0;
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function next_player(st) {
  if (st[/* turn_ended */11]) {
    if (game_ended(st)) {
      return /* record */[
              /* player_index */st[/* player_index */0],
              /* players */st[/* players */1],
              /* routes */st[/* routes */2],
              /* destination_deck */st[/* destination_deck */3],
              /* destination_trash */st[/* destination_trash */4],
              /* choose_destinations */st[/* choose_destinations */5],
              /* train_deck */st[/* train_deck */6],
              /* facing_up_trains */st[/* facing_up_trains */7],
              /* train_trash */st[/* train_trash */8],
              /* taking_routes */st[/* taking_routes */9],
              /* error */"Game has ended.",
              /* turn_ended */st[/* turn_ended */11],
              /* last_round */st[/* last_round */12]
            ];
    } else {
      var next_player$1 = Caml_int32.mod_(st[/* player_index */0] + 1 | 0, List.length(st[/* players */1]));
      var st$prime_001 = /* players */st[/* players */1];
      var st$prime_002 = /* routes */st[/* routes */2];
      var st$prime_003 = /* destination_deck */st[/* destination_deck */3];
      var st$prime_004 = /* destination_trash */st[/* destination_trash */4];
      var st$prime_005 = /* choose_destinations */st[/* choose_destinations */5];
      var st$prime_006 = /* train_deck */st[/* train_deck */6];
      var st$prime_007 = /* facing_up_trains */st[/* facing_up_trains */7];
      var st$prime_008 = /* train_trash */st[/* train_trash */8];
      var st$prime_009 = /* taking_routes */st[/* taking_routes */9];
      var st$prime_010 = /* error */st[/* error */10];
      var st$prime_011 = /* turn_ended */st[/* turn_ended */11];
      var st$prime_012 = /* last_round */st[/* last_round */12];
      var st$prime = /* record */[
        /* player_index */next_player$1,
        st$prime_001,
        st$prime_002,
        st$prime_003,
        st$prime_004,
        st$prime_005,
        st$prime_006,
        st$prime_007,
        st$prime_008,
        st$prime_009,
        st$prime_010,
        st$prime_011,
        st$prime_012
      ];
      if (check_last_round(st) || st[/* last_round */12]) {
        var p$prime = Player.set_last_turn(current_player(st$prime));
        return /* record */[
                /* player_index */next_player$1,
                /* players */update_players(next_player$1, p$prime, st$prime_001),
                st$prime_002,
                st$prime_003,
                st$prime_004,
                st$prime_005,
                st$prime_006,
                st$prime_007,
                st$prime_008,
                st$prime_009,
                st$prime_010,
                /* turn_ended */false,
                /* last_round */true
              ];
      } else {
        return st$prime;
      }
    }
  } else {
    return /* record */[
            /* player_index */st[/* player_index */0],
            /* players */st[/* players */1],
            /* routes */st[/* routes */2],
            /* destination_deck */st[/* destination_deck */3],
            /* destination_trash */st[/* destination_trash */4],
            /* choose_destinations */st[/* choose_destinations */5],
            /* train_deck */st[/* train_deck */6],
            /* facing_up_trains */st[/* facing_up_trains */7],
            /* train_trash */st[/* train_trash */8],
            /* taking_routes */st[/* taking_routes */9],
            /* error */"Turn has not ended yet for the current player.",
            /* turn_ended */st[/* turn_ended */11],
            /* last_round */st[/* last_round */12]
          ];
  }
}

function draw_card_facing_up(st, i) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var match = Components.TrainDeck[/* draw_faceup */7](st[/* train_deck */6], i, st[/* facing_up_trains */7], st[/* train_trash */8]);
    var match$1 = match[1];
    var p$prime = Player.draw_train_card(current_player(st), match[0]);
    var i$1 = st[/* player_index */0];
    return /* record */[
            /* player_index */st[/* player_index */0],
            /* players */update_players(i$1, p$prime, st[/* players */1]),
            /* routes */st[/* routes */2],
            /* destination_deck */st[/* destination_deck */3],
            /* destination_trash */st[/* destination_trash */4],
            /* choose_destinations */st[/* choose_destinations */5],
            /* train_deck */match$1[1],
            /* facing_up_trains */match$1[0],
            /* train_trash */match$1[2],
            /* taking_routes */st[/* taking_routes */9],
            /* error */st[/* error */10],
            /* turn_ended */true,
            /* last_round */st[/* last_round */12]
          ];
  }
}

function draw_card_pile_no_error(st) {
  var tr = st[/* train_trash */8];
  var match = Components.TrainDeck[/* draw_card */3](st[/* train_deck */6], tr);
  var match$1 = Components.TrainDeck[/* draw_card */3](match[1], tr);
  var p$prime = Player.draw_train_card(current_player(st), match[0]);
  var p$prime$prime = Player.draw_train_card(p$prime, match$1[0]);
  var i = st[/* player_index */0];
  return /* record */[
          /* player_index */st[/* player_index */0],
          /* players */update_players(i, p$prime$prime, st[/* players */1]),
          /* routes */st[/* routes */2],
          /* destination_deck */st[/* destination_deck */3],
          /* destination_trash */st[/* destination_trash */4],
          /* choose_destinations */st[/* choose_destinations */5],
          /* train_deck */match$1[1],
          /* facing_up_trains */st[/* facing_up_trains */7],
          /* train_trash */match$1[2],
          /* taking_routes */st[/* taking_routes */9],
          /* error */st[/* error */10],
          /* turn_ended */st[/* turn_ended */11],
          /* last_round */st[/* last_round */12]
        ];
}

function draw_card_pile(st) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var st$prime = draw_card_pile_no_error(st);
    return /* record */[
            /* player_index */st$prime[/* player_index */0],
            /* players */st$prime[/* players */1],
            /* routes */st$prime[/* routes */2],
            /* destination_deck */st$prime[/* destination_deck */3],
            /* destination_trash */st$prime[/* destination_trash */4],
            /* choose_destinations */st$prime[/* choose_destinations */5],
            /* train_deck */st$prime[/* train_deck */6],
            /* facing_up_trains */st$prime[/* facing_up_trains */7],
            /* train_trash */st$prime[/* train_trash */8],
            /* taking_routes */st$prime[/* taking_routes */9],
            /* error */st$prime[/* error */10],
            /* turn_ended */true,
            /* last_round */st$prime[/* last_round */12]
          ];
  }
}

function take_route(st) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var deck = st[/* destination_deck */3];
    var tr = st[/* destination_trash */4];
    var match = Components.DestinationDeck[/* draw_card */4](deck, tr);
    return /* record */[
            /* player_index */st[/* player_index */0],
            /* players */st[/* players */1],
            /* routes */st[/* routes */2],
            /* destination_deck */match[1],
            /* destination_trash */st[/* destination_trash */4],
            /* choose_destinations */match[0],
            /* train_deck */st[/* train_deck */6],
            /* facing_up_trains */st[/* facing_up_trains */7],
            /* train_trash */st[/* train_trash */8],
            /* taking_routes */false,
            /* error */st[/* error */10],
            /* turn_ended */st[/* turn_ended */11],
            /* last_round */st[/* last_round */12]
          ];
  }
}

function setup_state(st) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var st1 = draw_card_pile_no_error(st);
    return take_route(draw_card_pile_no_error(st1));
  }
}

function decided_routes(st, indexes) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var p = current_player(st);
    var required_tickets = Player.first_turn(p) ? 2 : 1;
    var tickets_chosen = List.length(indexes);
    if (tickets_chosen >= required_tickets) {
      var choose = st[/* choose_destinations */5];
      var loop = function (_acc, _param) {
        while(true) {
          var param = _param;
          var acc = _acc;
          if (param) {
            _param = param[1];
            _acc = /* :: */[
              List.nth(choose, param[0]),
              acc
            ];
            continue ;
          } else {
            return acc;
          }
        };
      };
      var tickets = loop(/* [] */0, indexes);
      var p$prime = Player.update_destination_tickets(p, tickets);
      var i = st[/* player_index */0];
      return /* record */[
              /* player_index */st[/* player_index */0],
              /* players */update_players(i, p$prime, st[/* players */1]),
              /* routes */st[/* routes */2],
              /* destination_deck */st[/* destination_deck */3],
              /* destination_trash */st[/* destination_trash */4],
              /* choose_destinations : [] */0,
              /* train_deck */st[/* train_deck */6],
              /* facing_up_trains */st[/* facing_up_trains */7],
              /* train_trash */st[/* train_trash */8],
              /* taking_routes */false,
              /* error */"",
              /* turn_ended */true,
              /* last_round */st[/* last_round */12]
            ];
    } else {
      return /* record */[
              /* player_index */st[/* player_index */0],
              /* players */st[/* players */1],
              /* routes */st[/* routes */2],
              /* destination_deck */st[/* destination_deck */3],
              /* destination_trash */st[/* destination_trash */4],
              /* choose_destinations */st[/* choose_destinations */5],
              /* train_deck */st[/* train_deck */6],
              /* facing_up_trains */st[/* facing_up_trains */7],
              /* train_trash */st[/* train_trash */8],
              /* taking_routes */st[/* taking_routes */9],
              /* error */"Player only chose " + (String(tickets_chosen) + (" tickets, must take at least " + (String(required_tickets) + "."))),
              /* turn_ended */st[/* turn_ended */11],
              /* last_round */st[/* last_round */12]
            ];
    }
  }
}

function update_routes(routes, old_r, new_r) {
  var _acc = /* [] */0;
  var _param = routes;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (param) {
      var t = param[1];
      var h = param[0];
      if (Caml_obj.caml_equal(h, old_r)) {
        return Pervasives.$at(acc, /* :: */[
                    new_r,
                    t
                  ]);
      } else {
        _param = t;
        _acc = /* :: */[
          h,
          acc
        ];
        continue ;
      }
    } else {
      return acc;
    }
  };
}

function check_cards(cards, n, clr) {
  var loop = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = param[0];
        if (Caml_obj.caml_equal(match[0], clr)) {
          return match[1];
        } else {
          _param = param[1];
          continue ;
        }
      } else {
        return 0;
      }
    };
  };
  return loop(cards) >= n;
}

function select_route(st, r) {
  if (st[/* turn_ended */11]) {
    return turn_ended_error(st);
  } else {
    var clr = r[3];
    if (r[4]) {
      return /* record */[
              /* player_index */st[/* player_index */0],
              /* players */st[/* players */1],
              /* routes */st[/* routes */2],
              /* destination_deck */st[/* destination_deck */3],
              /* destination_trash */st[/* destination_trash */4],
              /* choose_destinations */st[/* choose_destinations */5],
              /* train_deck */st[/* train_deck */6],
              /* facing_up_trains */st[/* facing_up_trains */7],
              /* train_trash */st[/* train_trash */8],
              /* taking_routes */st[/* taking_routes */9],
              /* error */"Route already taken.",
              /* turn_ended */st[/* turn_ended */11],
              /* last_round */st[/* last_round */12]
            ];
    } else if (clr >= 9) {
      return /* record */[
              /* player_index */st[/* player_index */0],
              /* players */st[/* players */1],
              /* routes */st[/* routes */2],
              /* destination_deck */st[/* destination_deck */3],
              /* destination_trash */st[/* destination_trash */4],
              /* choose_destinations */st[/* choose_destinations */5],
              /* train_deck */st[/* train_deck */6],
              /* facing_up_trains */st[/* facing_up_trains */7],
              /* train_trash */st[/* train_trash */8],
              /* taking_routes */st[/* taking_routes */9],
              /* error */"Choose a train card color.",
              /* turn_ended */st[/* turn_ended */11],
              /* last_round */st[/* last_round */12]
            ];
    } else {
      var st$1 = st;
      var r$1 = r;
      var clr$1 = clr;
      if (st$1[/* turn_ended */11]) {
        return turn_ended_error(st$1);
      } else {
        var cards = Player.train_cards(current_player(st$1));
        var n = r$1[2];
        if (check_cards(cards, n, clr$1)) {
          var num_trains = Player.trains_remaining(current_player(st$1));
          if (num_trains >= n) {
            var p$prime = Player.place_train(current_player(st$1), r$1);
            var i = st$1[/* player_index */0];
            var p_clr = p$prime[/* color */0];
            var r$prime_000 = r$1[0];
            var r$prime_001 = r$1[1];
            var r$prime_002 = r$1[2];
            var r$prime_003 = r$1[3];
            var r$prime_004 = /* Some */[p_clr];
            var r$prime = /* tuple */[
              r$prime_000,
              r$prime_001,
              r$prime_002,
              r$prime_003,
              r$prime_004
            ];
            return /* record */[
                    /* player_index */st$1[/* player_index */0],
                    /* players */update_players(i, p$prime, st$1[/* players */1]),
                    /* routes */update_routes(st$1[/* routes */2], r$1, r$prime),
                    /* destination_deck */st$1[/* destination_deck */3],
                    /* destination_trash */st$1[/* destination_trash */4],
                    /* choose_destinations */st$1[/* choose_destinations */5],
                    /* train_deck */st$1[/* train_deck */6],
                    /* facing_up_trains */st$1[/* facing_up_trains */7],
                    /* train_trash */st$1[/* train_trash */8],
                    /* taking_routes */st$1[/* taking_routes */9],
                    /* error */"",
                    /* turn_ended */true,
                    /* last_round */st$1[/* last_round */12]
                  ];
          } else {
            return /* record */[
                    /* player_index */st$1[/* player_index */0],
                    /* players */st$1[/* players */1],
                    /* routes */st$1[/* routes */2],
                    /* destination_deck */st$1[/* destination_deck */3],
                    /* destination_trash */st$1[/* destination_trash */4],
                    /* choose_destinations */st$1[/* choose_destinations */5],
                    /* train_deck */st$1[/* train_deck */6],
                    /* facing_up_trains */st$1[/* facing_up_trains */7],
                    /* train_trash */st$1[/* train_trash */8],
                    /* taking_routes */st$1[/* taking_routes */9],
                    /* error */"Not enough trains.",
                    /* turn_ended */st$1[/* turn_ended */11],
                    /* last_round */st$1[/* last_round */12]
                  ];
          }
        } else {
          return /* record */[
                  /* player_index */st$1[/* player_index */0],
                  /* players */st$1[/* players */1],
                  /* routes */st$1[/* routes */2],
                  /* destination_deck */st$1[/* destination_deck */3],
                  /* destination_trash */st$1[/* destination_trash */4],
                  /* choose_destinations */st$1[/* choose_destinations */5],
                  /* train_deck */st$1[/* train_deck */6],
                  /* facing_up_trains */st$1[/* facing_up_trains */7],
                  /* train_trash */st$1[/* train_trash */8],
                  /* taking_routes */st$1[/* taking_routes */9],
                  /* error */"Not enough train cards.",
                  /* turn_ended */st$1[/* turn_ended */11],
                  /* last_round */st$1[/* last_round */12]
                ];
        }
      }
    }
  }
}

function longest_route(st) {
  var first = List.hd(st[/* players */1]);
  var _plyrs = st[/* players */1];
  var _best = first;
  while(true) {
    var best = _best;
    var plyrs = _plyrs;
    if (List.length(plyrs) > 0) {
      var p = List.hd(plyrs);
      var rest = List.tl(plyrs);
      if (Player.score(p) > Player.score(best)) {
        _best = p;
        _plyrs = rest;
        continue ;
      } else {
        _plyrs = rest;
        continue ;
      }
    } else {
      return best;
    }
  };
}

exports.init_state = init_state;
exports.current_player = current_player;
exports.players = players;
exports.routes = routes;
exports.destination_items = destination_items;
exports.train_items = train_items;
exports.message = message;
exports.turn_ended = turn_ended;
exports.last_round = last_round;
exports.choose_destinations = choose_destinations;
exports.score = score;
exports.setup_state = setup_state;
exports.next_player = next_player;
exports.draw_card_pile = draw_card_pile;
exports.draw_card_facing_up = draw_card_facing_up;
exports.take_route = take_route;
exports.decided_routes = decided_routes;
exports.select_route = select_route;
exports.longest_route = longest_route;
/* Board Not a pure module */
